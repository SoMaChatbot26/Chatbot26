## 랭킹 시스템

### constraints
1. 유저 중복 허용 x -> 중복 있을 경우 체크해서 더 높은 점수를 저장
2. 점수 기준 내림차순으로 랭크 정렬
3. 같은 점수가 있을 경우 같은 등수로 처리 ex) 1등, 2등, 2등, 4등, 5등, 5등, 5등, 8등

### description
* saveInfo로 유저의 가위바위보 결과(연속 승수) 저장하고 정렬
* getAllRank로 모든 사용자의 랭킹 처리
* getTopTenRank로 상위 10명의 랭킹 처리

```js
const express = require('express');

let userInfo = [];

exports.saveInfo = (users, reactUserId, winCnt) => { // users.list 응답 객체, 응답 사용자 id, 연속 승수  
	const userIdx = userInfo.findIndex(obj => obj.id === reactUserId);
	const hasRank = userIdx === -1 ? false: true; // 랭크를 이미 가지고 있는지 여부
	
	for (let user of users) {
		if (parseInt(user.id) === reactUserId) { // 메시지에 응답한 유저가 유저 목록에 있는 유저일 경우
			if (hasRank) { // 이미 랭크를 가지고 있고 
				if (userInfo[userIdx].point < winCnt) { // 현재 점수가 이전 점수보다 높다면
					userInfo[userIdx].point = winCnt; // 갱신
				};
				break;
			};
			userInfo.push({id: reactUserId, name: user.name, point: winCnt});
			break;
		};
	};
	
	// 점수 기준 내림차순으로 정렬
	userInfo.sort((rank1, rank2) => {
		return rank2.point - rank1.point;
	});
};

exports.getAllRank = () => {
	let allRankInfo = [];
	allRankInfo.push({"rank": 1, "name": userInfo[0].name, "point": userInfo[0].point});
	
	for (let i = 1; i < Object.keys(userInfo).length; i++) {
		// 같은 점수일 경우 같은 등수로 처리 ex) 1등, 2등, 2등, 4등
		if (userInfo[i].point === userInfo[i-1].point) {
			allRankInfo.push({"rank": allRankInfo[i-1].rank, "name": userInfo[i].name, "point": userInfo[i].point});
			continue;
		};
		allRankInfo.push({"rank": i+1, "name": userInfo[i].name, "point": userInfo[i].point});
	};
	
	return allRankInfo;
};

exports.getTopTenRank = (allRankInfo) => {
	let topTenRankInfo = [];

	for (let i = 0; i < 10; i ++) {
		if (allRankInfo[i] === undefined) // allRankInfo가 10개 미만일 경우
			break;
		topTenRankInfo.push(allRankInfo[i]);
	};	
	

	return topTenRankInfo;
};
```
